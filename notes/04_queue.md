#队列

**先进者先出**，这就是典型的“队列”。

**栈**只支持两个基本操作：**入栈 push()**和**出栈 pop**()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：**入队 enqueue()**，**放**一个数据到队列**尾部**；**出队 dequeue()**，从队列**头部取**一个元素。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/hongguangli/Figures/main/20221203235545.png" width=500>
</center>

所以，队列跟栈一样，也是一种操作受限的**线性表**数据结构。

数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列**。

##循环队列

循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。我画了一张图，你可以直观地感受一下。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/hongguangli/Figures/main/20221204000417.png" width=500>
</center>

要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，确定好**队空**和**队满**的判定条件。

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/hongguangli/Figures/main/20221205002318.png" width=500>
</center>

总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，**(tail+1)%n=head**。
**当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会==浪费一个==数组的存储空间。**

##阻塞队列和并发队列
阻塞队列其实就是在队列基础上**增加了阻塞操作**。简单来说，就是在队列为**空**的时候，从队头**取数据会被阻塞**。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经**满**了，那么**插入数据**的操作就会被**阻塞**，直到队列中有空闲位置后再插入数据，然后再返回。

上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！

**线程安全的队列**我们叫作**并发队列**。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上**加锁**，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，**基于数组的循环队列**，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是**循环队列比链式队列应用更加广泛的原因**。
